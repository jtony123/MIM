package datastructures;import java.util.List;/** * A class that implements the ADT binary tree. *  * @author Frank M. Carrano * @version 2.0 */public class BinaryTree<T> implements BinaryTreeInterface<T>, java.io.Serializable{	private static final long serialVersionUID = -1932834476575953631L;	private BinaryNodeInterface<T> root;	public BinaryTree()	{		root = null;	} // end default constructor	public BinaryTree(T rootData)	{		root = new BinaryNode<T>(rootData);	} // end constructor	public BinaryTree(T rootData, BinaryTree<T> leftTree, 			BinaryTree<T> rightTree)	{		privateSetTree(rootData, leftTree, rightTree);	} // end constructor	public void setTree(T rootData)	{		root = new BinaryNode<T>(rootData);	} // end setTree	public void setTree(T rootData, BinaryTreeInterface<T> leftTree,			BinaryTreeInterface<T> rightTree)	{		privateSetTree(rootData, (BinaryTree<T>)leftTree, 				(BinaryTree<T>)rightTree);	} // end setTree	// 26.08	private void privateSetTree(T rootData, BinaryTree<T> leftTree, 			BinaryTree<T> rightTree)	{		root = new BinaryNode<T>(rootData);		if ((leftTree != null) && !leftTree.isEmpty())			root.setLeftChild(leftTree.root);		if ((rightTree != null) && !rightTree.isEmpty())		{			if (rightTree != leftTree)				root.setRightChild(rightTree.root);			else				root.setRightChild(rightTree.root.copy());		} // end if		if ((leftTree != null) && (leftTree != this))			leftTree.clear(); 		if ((rightTree != null) && (rightTree != this))			rightTree.clear();	} // end privateSetTree		// 26.09	public T getRootData()	{		T rootData = null;		if (root != null)			rootData = root.getData();		return rootData;	} // end getRootData	// 26.09	public boolean isEmpty()	{		return root == null;	} // end isEmpty	// 26.09	public void clear()	{		root = null;	} // end clear	// 26.09	protected void setRootData(T rootData)	{		root.setData(rootData);	} // end setRootData	// 26.09	protected void setRootNode(BinaryNodeInterface<T> rootNode)	{		root = rootNode;	} // end setRootNode	// 26.09	protected BinaryNodeInterface<T> getRootNode()	{		return root;	} // end getRootNode	// 26.10	public int getHeight()	{		return root.getHeight();	} // end getHeight	// 26.10	public int getNumberOfNodes()	{		return root.getNumberOfNodes();	} // end getNumberOfNodes		public void calculateNtf() {		// TODO Auto-generated method stub		calculateNtf(root);			}		private void calculateNtf(BinaryNodeInterface<T> node) {		// TODO Auto-generated method stub		if (node != null)		{			calculateNtf(node.getLeftChild());							//System.out.println("term = " + node.getData() + " : df = " + node.getDocumentFrequency() + " : " );			for(Posting post: node.getPostings()){								post.setNtf(post.getTermFrequency(), post.getDocument().getVectorLength());								//System.out.print(" :: "+post.getDocumentId() + ", ntf = " + post.getNtf());			}			//System.out.println();			calculateNtf(node.getRightChild());		} // end if			}			/**	 * @param averageDocumentLength	 */	public void calculateTfBM25(double averageDocumentLength) {		// TODO Auto-generated method stub		calculateTfBM25(root, averageDocumentLength);	}		private void calculateTfBM25(BinaryNodeInterface<T> node, double avgDoclen) {		// TODO Auto-generated method stub		if (node != null)		{			calculateTfBM25(node.getLeftChild(), avgDoclen);							//System.out.println("term = " + node.getData() + " : df = " + node.getDocumentFrequency() + " : " );			for(Posting post: node.getPostings()){								//post.setNtf(post.getTermFrequency(), post.getDocument().getVectorLength());					post.setTfBM25((double)post.getDocument().getDocumentTokens().size(), avgDoclen);				//System.out.print(" :: "+post.getDocumentId() + ", ntf = " + post.getNtf());			}			//System.out.println();			calculateTfBM25(node.getRightChild(), avgDoclen);		} // end if			}							// 26.12	public void inorderTraverse() 	{		inorderTraverse(root);	} // end inorderTraverse	private void inorderTraverse(BinaryNodeInterface<T> node) 	{		if (node != null)		{			inorderTraverse(node.getLeftChild());			System.out.print(node.getData() + " : " );//+ node.getDocumentFrequency() + " : " + node.getIdf()+" ");			System.out.print("postings: ");			for(Posting i: node.getPostings()){				System.out.print("docId "+i.getDocumentId() + ", ");				for(Integer x: i.getTermPositions()){					System.out.print("termPos " +x+", ");				}			}			System.out.println();			inorderTraverse(node.getRightChild());		} // end if	} // end inorderTraverse} // end BinaryTree